import { EventEmitter } from 'node:events';

interface ConnectorOptions {
    client: unknown;
    sendPacket: (client: unknown, shardId: number, payload: unknown) => void;
    listenEvent: (client: unknown, handler: (packet: any) => void) => void;
}
declare const AllowedPackets: string[];
/**
 * Wrapper class around shoukaku to Discord websocket communication
 */
declare class Connector {
    protected readonly manager: Shoukaku;
    protected readonly options: ConnectorOptions;
    constructor(manager: Shoukaku, options: ConnectorOptions);
    private handleRaw;
    sendPacket(shardId: number, payload: unknown): void;
}
/**
 * @param client Discord.JS client
 * Creates a DiscordJS Connector option
 */
declare function createDiscordJSOptions(client: unknown): ConnectorOptions;
/**
 * @param client Eris client
 * Creates an Eris Connector option
 */
declare function createErisOptions(client: unknown): ConnectorOptions;
/**
 * @param client OceanicJS client
 * Creates a OceanicJS Connector option
 */
declare function createOceanicOptions(client: unknown): ConnectorOptions;
/**
 * @param client Seyfert client
 * Creates a Seyfert Connector option
 */
declare function createSeyfertOptions(client: unknown): ConnectorOptions;

declare enum ConnectionState {
    Connecting = 0,
    Connected = 1,
    Disconnecting = 2,
    Disconnected = 3
}
declare enum VoiceState {
    SessionReady = 0,
    SessionIdMissing = 1,
    AbortError = 2,
    SessionEndpointMissing = 3,
    SessionFailedUpdate = 4
}
declare enum Events {
    Reconnecting = "reconnecting",
    Debug = "debug",
    Error = "error",
    Ready = "ready",
    Close = "close",
    Disconnect = "disconnect",
    PlayerUpdate = "playerUpdate",
    PlayerEvent = "playerEvent"
}

declare enum LavalinkOpCodes {
    Ready = "ready",
    PlayerUpdate = "playerUpdate",
    Stats = "stats",
    Event = "event"
}
interface Ready {
    op: LavalinkOpCodes.Ready;
    resumed: boolean;
    sessionId: string;
}
interface NodeMemory {
    reservable: number;
    used: number;
    free: number;
    allocated: number;
}
interface NodeFrameStats {
    sent: number;
    deficit: number;
    nulled: number;
}
interface NodeCpu {
    cores: number;
    systemLoad: number;
    lavalinkLoad: number;
}
interface Stats {
    op: LavalinkOpCodes.Stats;
    players: number;
    playingPlayers: number;
    memory: NodeMemory;
    frameStats: NodeFrameStats | null;
    cpu: NodeCpu;
    uptime: number;
}
interface NodeInfoVersion {
    semver: string;
    major: number;
    minor: number;
    patch: number;
    preRelease?: string;
    build?: string;
}
interface NodeInfoGit {
    branch: string;
    commit: string;
    commitTime: number;
}
interface NodeInfoPlugin {
    name: string;
    version: string;
}
interface NodeInfo {
    version: NodeInfoVersion;
    buildTime: number;
    git: NodeInfoGit;
    jvm: string;
    lavaplayer: string;
    sourceManagers: string[];
    filters: string[];
    plugins: NodeInfoPlugin[];
}

type TrackEndReason = 'finished' | 'loadFailed' | 'stopped' | 'replaced' | 'cleanup';
type PlayOptions = Omit<UpdatePlayerOptions, 'filters' | 'voice'>;
declare enum PlayerEventType {
    TrackStartEvent = "TrackStartEvent",
    TrackEndEvent = "TrackEndEvent",
    TrackExceptionEvent = "TrackExceptionEvent",
    TrackStuckEvent = "TrackStuckEvent",
    WebsocketClosedEvent = "WebSocketClosedEvent"
}
interface Band {
    band: number;
    gain: number;
}
interface KaraokeSettings {
    level?: number;
    monoLevel?: number;
    filterBand?: number;
    filterWidth?: number;
}
interface TimescaleSettings {
    speed?: number;
    pitch?: number;
    rate?: number;
}
interface FreqSettings {
    frequency?: number;
    depth?: number;
}
interface RotationSettings {
    rotationHz?: number;
}
interface DistortionSettings {
    sinOffset?: number;
    sinScale?: number;
    cosOffset?: number;
    cosScale?: number;
    tanOffset?: number;
    tanScale?: number;
    offset?: number;
    scale?: number;
}
interface ChannelMixSettings {
    leftToLeft?: number;
    leftToRight?: number;
    rightToLeft?: number;
    rightToRight?: number;
}
interface LowPassSettings {
    smoothing?: number;
}
interface PlayerEvent {
    op: LavalinkOpCodes.Event;
    guildId: string;
}
interface TrackStartEvent extends PlayerEvent {
    type: PlayerEventType.TrackStartEvent;
    track: Track;
}
interface TrackEndEvent extends PlayerEvent {
    type: PlayerEventType.TrackEndEvent;
    track: Track;
    reason: TrackEndReason;
}
interface TrackStuckEvent extends PlayerEvent {
    type: PlayerEventType.TrackStuckEvent;
    track: Track;
    thresholdMs: number;
}
interface TrackExceptionEvent extends PlayerEvent {
    type: PlayerEventType.TrackExceptionEvent;
    exception: Exception;
}
interface WebSocketClosedEvent extends PlayerEvent {
    type: PlayerEventType.WebsocketClosedEvent;
    code: number;
    byRemote: boolean;
    reason: string;
}
interface PlayerUpdate {
    op: LavalinkOpCodes.PlayerUpdate;
    state: {
        connected: boolean;
        position: number;
        time: number;
        ping: number;
    };
    guildId: string;
}
interface FilterOptions {
    volume?: number;
    equalizer?: Band[];
    karaoke?: KaraokeSettings | null;
    timescale?: TimescaleSettings | null;
    tremolo?: FreqSettings | null;
    vibrato?: FreqSettings | null;
    rotation?: RotationSettings | null;
    distortion?: DistortionSettings | null;
    channelMix?: ChannelMixSettings | null;
    lowPass?: LowPassSettings | null;
}

type Severity = 'common' | 'suspicious' | 'fault';
declare enum LoadType {
    Track = "track",
    Playlist = "playlist",
    Search = "search",
    Empty = "empty",
    Error = "error"
}
interface Track {
    encoded: string;
    info: {
        identifier: string;
        isSeekable: boolean;
        author: string;
        length: number;
        isStream: boolean;
        position: number;
        title: string;
        uri?: string;
        artworkUrl?: string;
        isrc?: string;
        sourceName: string;
    };
    pluginInfo: unknown;
}
interface Playlist {
    encoded: string;
    info: {
        name: string;
        selectedTrack: number;
    };
    pluginInfo: unknown;
    tracks: Track[];
}
interface Exception {
    message: string;
    severity: Severity;
    cause: string;
}
interface TrackResult {
    loadType: LoadType.Track;
    data: Track;
}
interface PlaylistResult {
    loadType: LoadType.Playlist;
    data: Playlist;
}
interface SearchResult {
    loadType: LoadType.Search;
    data: Track[];
}
interface EmptyResult {
    loadType: LoadType.Empty;
    data: Record<string, never>;
}
interface ErrorResult {
    loadType: LoadType.Error;
    data: Exception;
}
type LavalinkResponse = TrackResult | PlaylistResult | SearchResult | EmptyResult | ErrorResult;
interface Address {
    address: string;
    failingTimestamp: number;
    failingTime: string;
}
interface RoutePlanner {
    class: null | 'RotatingIpRoutePlanner' | 'NanoIpRoutePlanner' | 'RotatingNanoIpRoutePlanner' | 'BalancingIpRoutePlanner';
    details: null | {
        ipBlock: {
            type: string;
            size: string;
        };
        failingAddresses: Address[];
        rotateIndex: string;
        ipIndex: string;
        currentAddress: string;
        blockIndex: string;
        currentAddressIndex: string;
    };
}
interface LavalinkPlayerVoice {
    token: string;
    endpoint: string;
    sessionId: string;
    connected?: boolean;
    ping?: number;
}
type LavalinkPlayerVoiceOptions = Omit<LavalinkPlayerVoice, 'connected' | 'ping'>;
interface LavalinkPlayer {
    guildId: string;
    track?: Track;
    volume: number;
    paused: boolean;
    voice: LavalinkPlayerVoice;
    filters: FilterOptions;
}
interface UpdatePlayerTrackOptions {
    encoded?: string | null;
    identifier?: string;
    userData?: unknown;
}
interface UpdatePlayerOptions {
    track?: UpdatePlayerTrackOptions;
    position?: number;
    endTime?: number;
    volume?: number;
    paused?: boolean;
    filters?: FilterOptions;
    voice?: LavalinkPlayerVoiceOptions;
}
interface UpdatePlayerInfo {
    guildId: string;
    playerOptions: UpdatePlayerOptions;
    noReplace?: boolean;
}
interface SessionInfo {
    resumingKey?: string;
    timeout: number;
}

interface FetchOptions {
    endpoint: string;
    options: {
        headers?: Record<string, string>;
        params?: Record<string, string>;
        method?: string;
        body?: Record<string, unknown>;
        [key: string]: unknown;
    };
}
/**
 * Wrapper around Lavalink REST API
 */
declare class Rest {
    /**
     * Node that initialized this instance
     */
    protected readonly node: Node;
    /**
     * URL of Lavalink
     */
    protected readonly url: string;
    /**
     * Credentials to access Lavalink
     */
    protected readonly auth: string;
    /**
     * @param node An instance of Node
     * @param options The options to initialize this rest class
     * @param options.name Name of this node
     * @param options.url URL of Lavalink
     * @param options.auth Credentials to access Lavalink
     * @param options.secure Weather to use secure protocols or not
     * @param options.group Group of this node
     */
    constructor(node: Node, options: NodeOption);
    protected get sessionId(): string;
    /**
     * Resolve a track
     * @param identifier Track ID
     * @returns A promise that resolves to a Lavalink response
     */
    resolve(identifier: string): Promise<LavalinkResponse>;
    /**
     * Decode a track
     * @param track Encoded track
     * @returns Promise that resolves to a track
     */
    decode(track: string): Promise<Track>;
    /**
     * Gets all the player with the specified sessionId
     * @returns Promise that resolves to an array of Lavalink players
     */
    getPlayers(): Promise<LavalinkPlayer[]>;
    /**
     * Gets the player with the specified guildId
     * @returns Promise that resolves to a Lavalink player
     */
    getPlayer(guildId: string): Promise<LavalinkPlayer>;
    /**
     * Updates a Lavalink player
     * @param guildId GuildId of the player you want to update
     * @param updatePlayerOptions Data to update on the player
     * @param noReplace If you want this action to do nothing when the player is active
     * @returns Promise that resolves to a Lavalink player
     */
    updatePlayer(guildId: string, updatePlayerOptions: UpdatePlayerOptions, noReplace?: boolean): Promise<LavalinkPlayer>;
    /**
     * Deletes a Lavalink player
     * @param guildId guildId where this player is
     */
    destroyPlayer(guildId: string): Promise<void>;
    /**
     * Updates the session with a resume boolean and timeout
     * @param resuming Whether resuming is enabled for this session or not
     * @param timeout Timeout to wait for resuming
     * @returns Promise that resolves to a Lavalink player
     */
    updateSession(resuming?: boolean, timeout?: number): Promise<SessionInfo>;
    /**
     * Gets the status of this node
     * @returns Promise that resolves to a node stats response
     */
    stats(): Promise<Stats>;
    /**
     * Get routeplanner status from Lavalink
     * @returns Promise that resolves to a routeplanner response
     */
    getRoutePlannerStatus(): Promise<RoutePlanner>;
    /**
     * Release blacklisted IP address into pool of IPs
     * @param address IP address
     */
    unmarkFailedAddress(address: string): Promise<void>;
    /**
     * Get Lavalink info
     */
    getLavalinkInfo(): Promise<NodeInfo>;
    /**
     * Make a request to Lavalink
     * @param fetchOptions.endpoint Lavalink endpoint
     * @param fetchOptions.options Options passed to fetch
     * @throws `RestError` when encountering a Lavalink error response
     * @internal
     */
    protected fetch<T = unknown>(fetchOptions: FetchOptions): Promise<T | undefined>;
}
interface LavalinkRestError {
    timestamp: number;
    status: number;
    error: string;
    trace?: string;
    message: string;
    path: string;
}
declare class RestError extends Error {
    timestamp: number;
    status: number;
    error: string;
    trace?: string;
    path: string;
    constructor({ timestamp, status, error, trace, message, path }: LavalinkRestError);
}

interface ResumableHeaders {
    [key: string]: string;
    'Client-Name': string;
    'User-Agent': string;
    'Authorization': string;
    'User-Id': string;
    'Session-Id': string;
}
type NonResumableHeaders = Omit<ResumableHeaders, 'Session-Id'>;
/**
 * Represents a Lavalink node
 */
declare class Node {
    #private;
    /**
     * Shoukaku class
     */
    readonly manager: Shoukaku;
    /**
     * Lavalink rest API
     */
    readonly rest: Rest;
    /**
     * Name of this node
     */
    readonly name: string;
    /**
     * Group in which this node is contained
     */
    readonly group?: string;
    /**
     * URL of Lavalink
     */
    private readonly url;
    /**
     * Credentials to access Lavalink
     */
    private readonly auth;
    /**
     * The state of this connection
     * @readonly
     */
    state: ConnectionState;
    /**
     * The number of reconnects to Lavalink
     * @readonly
     */
    reconnects: number;
    /**
     * Statistics from Lavalink
     * @readonly
     */
    stats: Stats | null;
    /**
     * Information about lavalink node
     * @readonly
    */
    info: NodeInfo | null;
    /**
     * SessionId of this Lavalink connection (not to be confused with Discord SessionId)
     * @readonly
     */
    sessionId: string | null;
    /**
     * Connections that are referenced by this node
     * @internal
     */
    connections: WeakSet<Connection>;
    /**
     * @param manager Shoukaku instance
     * @param options Options on creating this node
     * @param options.name Name of this node
     * @param options.url URL of Lavalink
     * @param options.auth Credentials to access Lavalnk
     * @param options.secure Whether to use secure protocols or not
     * @param options.group Group of this node
     */
    constructor(manager: Shoukaku, options: NodeOption);
    /**
     * Penalties for load balancing
     * @returns Penalty score
     * @readonly
     */
    get penalties(): number;
    /**
     * Node connections, this exists because weaksets can't be iterated on
     * @returns An array of connections being referenced by this node
     * @readonly
     * @internal
     */
    get mappedConnections(): Connection[];
    /**
     * Connect to Lavalink
     * @internal
     */
    connect(): Promise<void>;
    /**
     * Disconnect from Lavalink
     * @param code Status code
     * @param reason Reason for disconnect
     * @internal
     */
    destroy(code: number, reason?: string): void;
    /**
     * Handle message from Lavalink
     * @param message JSON message
     * @private
     * @internal
     */
    private message;
    /**
     * Handle closed event from lavalink
     * @param code Status close
     * @param reason Reason for connection close
     * @param destroy If we should not try to connect again
     * @private
     * @internal
     */
    private close;
    /**
     * @private
     * @internal
     */
    private handleOnDisconnect;
    /**
     * To emit error events easily
     * @param error error message
     * @private
     * @internal
     */
    private error;
}

/**
 * Represents the partial payload from a stateUpdate event
 */
interface StateUpdatePartial {
    channel_id?: string;
    session_id?: string;
    self_deaf: boolean;
    self_mute: boolean;
}
/**
 * Represents the payload from a serverUpdate event
 */
interface ServerUpdate {
    token: string;
    guild_id: string;
    endpoint: string;
}
/**
 * Represents a connection to a Discord voice channel
 */
declare class Connection extends EventEmitter {
    /**
     * The manager where this connection is on
     */
    manager: Shoukaku;
    /**
     * GuildId of the connection that is being managed by this instance
     */
    guildId: string;
    /**
     * VoiceChannelId of the connection that is being managed by this instance
     */
    channelId: string | null;
    /**
     * ShardId where this connection sends data on
     */
    shardId: number;
    /**
     * Mute status in connected voice channel
     */
    muted: boolean;
    /**
     * Deafen status in connected voice channel
     */
    deafened: boolean;
    /**
     * Id of the currently active voice channel connection
     */
    sessionId: string | null;
    /**
     * Region of connected voice channel
     */
    region: string | null;
    /**
     * Cached serverUpdate event from Lavalink
     */
    serverUpdate: ServerUpdate | null;
    /**
     * Connection state
     */
    state: ConnectionState;
    /**
     * @param manager The manager of this connection
     * @param options The options to pass in connection creation
     * @param options.guildId GuildId in which voice channel to connect to is located
     * @param options.shardId ShardId in which the guild exists
     * @param options.channelId ChannelId of voice channel to connect to
     * @param options.deaf Optional boolean value to specify whether to deafen the current bot user
     * @param options.mute Optional boolean value to specify whether to mute the current bot user
     */
    constructor(manager: Shoukaku, options: VoiceChannelOptions);
    getNode(): Node | undefined;
    /**
     * Set the deafen status for the current bot user
     * @param deaf Boolean value to indicate whether to deafen or un-deafen
     * @defaultValue false
     */
    setDeaf(deaf?: boolean): void;
    /**
     * Set the mute status for the current bot user
     * @param mute Boolean value to indicate whether to mute or unmute
     * @defaultValue false
     */
    setMute(mute?: boolean): void;
    /**
     * Disconnect the current bot user from the connected voice channel
     * @internal
     */
    disconnect(): void;
    /**
     * Connect the current bot user to a voice channel
     * @internal
     */
    connect(): Promise<void>;
    /**
     * Updates SessionId, ChannelId, Deafen and Mute data of this instance
     * @param options
     * @param options.session_id Id of the current session
     * @param options.channel_id Id of the connected voice channel
     * @param options.self_deaf Boolean that indicates if the current bot user is deafened or not
     * @param options.self_mute Boolean that indicates if the current bot user is muted or not
     * @internal
     */
    setStateUpdate({ session_id, channel_id, self_deaf, self_mute }: StateUpdatePartial): void;
    /**
     * Sets the server update data for this connection
     * @internal
     */
    setServerUpdate(data: ServerUpdate): void;
    /**
     * Send voice data to discord
     * @internal
     */
    sendVoiceUpdate(): void;
    /**
     * Send data to Discord
     * @param data The data to send
     * @private
     * @internal
     */
    private send;
    /**
     * Emits a debug log
     * @private
     * @internal
     */
    private debug;
}

declare abstract class TypedEventEmitter<E extends string | symbol, T extends Record<E, unknown[]>> extends EventEmitter {
    protected constructor();
    on<K extends Extract<keyof T, string> | symbol>(eventName: K, listener: (...args: T[Extract<K, string>]) => void): this;
    once<K extends Extract<keyof T, string> | symbol>(eventName: K, listener: (...args: T[Extract<K, string>]) => void): this;
    off<K extends Extract<keyof T, string> | symbol>(eventName: K, listener: (...args: T[Extract<K, string>]) => void): this;
    emit<K extends Extract<keyof T, string> | symbol>(eventName: K, ...args: T[Extract<K, string>]): boolean;
}
type Constructor<T> = new (...args: unknown[]) => T;
/**
 * Merge the default options to user input
 * @param def Default options
 * @param given User input
 * @returns Merged options
 */
declare function mergeDefault<T extends Record<string, any>>(def: T, given: T): Required<T>;
/**
 * Wait for a specific amount of time (timeout)
 * @param ms Time to wait in milliseconds
 * @returns A promise that resolves in x seconds
 */
declare function wait(ms: number): Promise<void>;
declare function validate<T>(value: T | undefined): T;

type Utils_Constructor<T> = Constructor<T>;
type Utils_TypedEventEmitter<E extends string | symbol, T extends Record<E, unknown[]>> = TypedEventEmitter<E, T>;
declare const Utils_TypedEventEmitter: typeof TypedEventEmitter;
declare const Utils_mergeDefault: typeof mergeDefault;
declare const Utils_validate: typeof validate;
declare const Utils_wait: typeof wait;
declare namespace Utils {
  export { type Utils_Constructor as Constructor, Utils_TypedEventEmitter as TypedEventEmitter, Utils_mergeDefault as mergeDefault, Utils_validate as validate, Utils_wait as wait };
}

interface Structures {
    /**
     * A custom structure that extends the Rest class
     */
    rest?: Constructor<Rest>;
}
interface NodeOption {
    /**
     * Name of the Lavalink node
     */
    name: string;
    /**
     * Lavalink node host and port without any prefix
     */
    url: string;
    /**
     * Credentials to access Lavalink
     */
    auth: string;
    /**
     * Whether to use secure protocols or not
     */
    secure?: boolean;
    /**
     * Name of the Lavalink node group
     */
    group?: string;
}
interface RequiredOptions {
    /**
     * The user id of the bot where this client will connect on
     */
    userId: string;
    /**
     * List of lavalink nodes to use
     */
    nodes: NodeOption[];
    /**
     * Library connector for Discord Websocket
     */
    connectorOptions: ConnectorOptions;
}
interface OptionalOptions {
    /**
     * Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES)
     */
    resume?: boolean;
    /**
     * Time to wait before lavalink starts to destroy the players of the disconnected client
     */
    resumeTimeout?: number;
    /**
     * Number of times to try and reconnect to Lavalink before giving up
     */
    reconnectTries?: number;
    /**
     * Timeout before trying to reconnect
     */
    reconnectInterval?: number;
    /**
     * Time to wait for a response from the Lavalink REST API before giving up
     */
    restTimeout?: number;
    /**
     * Whether to move players to a different Lavalink node when a node disconnects
     */
    moveOnDisconnect?: boolean;
    /**
     * User Agent to use when making requests to Lavalink
     */
    userAgent?: string;
    /**
     * Custom structures for shoukaku to use
     */
    structures?: Structures;
    /**
     * Timeout before abort connection
     */
    voiceConnectionTimeout?: number;
    /**
     * Node Resolver to use if you want to customize it
     */
    nodeResolver?: (nodes: Node[], connection?: Connection) => Node | undefined;
}
interface VoiceChannelOptions {
    guildId: string;
    shardId: number;
    channelId: string;
    deaf?: boolean;
    mute?: boolean;
    node?: Node;
}
type ShoukakuEvents = {
    /**
     * Emitted when reconnect tries are occurring and how many tries are left
     * @eventProperty
     */
    [Events.Reconnecting]: [node: Node, reconnectsLeft: number, reconnectInterval: number];
    /**
     * Emitted when data useful for debugging is produced
     * @eventProperty
     */
    [Events.Debug]: [info: string];
    /**
     * Emitted when an error occurs
     * @eventProperty
     */
    [Events.Error]: [node: Node | NodeOption, error: Error];
    /**
     * Emitted when Shoukaku is ready to receive operations
     * @eventProperty
     */
    [Events.Ready]: [node: Node, lavalinkResume: boolean];
    /**
     * Emitted when a websocket connection to Lavalink is closed
     * @eventProperty
     */
    [Events.Close]: [node: Node, code: number, reason: string];
    /**
     * Emitted when a websocket connection to Lavalink is Disconnected
     * @eventProperty
     */
    [Events.Disconnect]: [node: Node];
    /**
     * Emitted when a player update event was received from lavalink
     * @eventProperty
     */
    [Events.PlayerUpdate]: [node: Node, data: PlayerUpdate];
    /**
     * Emitted when a player event was received from lavalink
     * @eventProperty
     */
    [Events.PlayerEvent]: [node: Node, data: TrackStartEvent | TrackEndEvent | TrackStuckEvent | TrackExceptionEvent | WebSocketClosedEvent];
};
/**
 * Main Shoukaku class
 */
declare class Shoukaku extends TypedEventEmitter<Events, ShoukakuEvents> {
    /**
     * Discord library connector
     */
    readonly connector: Connector;
    /**
     * Shoukaku options
     */
    readonly options: Required<OptionalOptions>;
    /**
     * Connected Lavalink nodes
     */
    readonly nodes: Node[];
    /**
     * Voice connections being handled
     */
    readonly connections: Connection[];
    /**
     * The user id of the user this instance is using
     */
    readonly userId: string;
    /**
     * @param required Required options for shoukaku to function
     * @param required.userId The user id of the user this instance will connect to
     * @param required.nodes List of initial nodes that the library will try to connect to
     * @param required.connectorOptions Options of the connector to communicate with Discord Websocket
     * @param optional Optional options to pass to create this Shoukaku instance
     * @param optional.resume Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES)
     * @param optional.resumeTimeout Time to wait before lavalink starts to destroy the players of the disconnected client
     * @param optional.resumeByLibrary Whether to resume the players by doing it in the library side (Client Side) (Note: TRIES TO RESUME REGARDLESS OF WHAT HAPPENED ON A LAVALINK SERVER)
     * @param optional.reconnectTries Number of times to try and reconnect to Lavalink before giving up
     * @param optional.reconnectInterval Timeout before trying to reconnect
     * @param optional.restTimeout Time to wait for a response from the Lavalink REST API before giving up
     * @param optional.moveOnDisconnect Whether to move players to a different Lavalink node when a node disconnects
     * @param optional.userAgent User Agent to use when making requests to Lavalink
     * @param optional.structures Custom structures for shoukaku to use
     * @param optional.nodeResolver Used if you have custom lavalink node resolving
     */
    constructor(required: RequiredOptions, optional?: OptionalOptions);
    /**
     * @returns The amount of cached player count
     */
    getPlayerCount(): number;
    /**
     * @returns The latest player count being handled
     */
    fetchPlayerCount(): Promise<number>;
    /**
     * Gets an ideal node based on the nodeResolver you provided
     * @param connection Optional connection class for ideal node selection, if you use it
     * @returns An ideal node for you to do things with
     */
    getIdealNode(connection?: Connection): Node | undefined;
    /**
     * Connects every node that shoukaku manages if it's disconnected
     */
    connect(): Promise<void>;
    /**
     * Connects a specific node shoukaku manages if it's disconnected
     * @param name Node name to connect
     */
    connectNodeNamed(name: string): Promise<void>;
    /**
     * Add a Lavalink node to the pool of available nodes then tries to connect it
     * @param options.name Name of this node
     * @param options.url URL of Lavalink
     * @param options.auth Credentials to access Lavalnk
     * @param options.secure Whether to use secure protocols or not
     * @param options.group Group of this node
     */
    addNode(options: NodeOption): Promise<void>;
    /**
     * Remove a Lavalink node from the pool of available nodes
     * @param name Name of the node
     * @param reason Reason of removing the node
     */
    removeNode(name: string, reason?: string): void;
    /**
     * Joins a voice channel
     * @param options.guildId GuildId in which the ChannelId of the voice channel is located
     * @param options.shardId ShardId to track where this should send on sharded websockets, put 0 if you are unsharded
     * @param options.channelId ChannelId of the voice channel you want to connect to
     * @param options.deaf Optional boolean value to specify whether to deafen or undeafen the current bot user
     * @param options.mute Optional boolean value to specify whether to mute or unmute the current bot user
     * @returns A weak reference to the connection, where you can create a new basic player by passing it to the class
     */
    joinVoiceChannel(options: VoiceChannelOptions): Promise<WeakRef<Connection>>;
    /**
     * Leaves a voice channel
     * @param guildId The id of the guild you want to delete
     * @returns The destroyed / disconnected player or undefined if none
     */
    leaveVoiceChannel(guildId: string): void;
    /**
     * Leaves current voice channel and joins a new one
     * @param guildId GuildId in which the ChannelId of the voice channel is located
     * @param channelId Id of channel to move to
     * @throws {@link Error} When guild does not have an existing connection, or could not be moved
     * @returns The moved player
     */
    moveVoiceChannel(guildId: string, channelId: string): void;
    /**
     * Deletes a connection from array
     * @param guildId
     * @internal
     * @private
     */
    private deleteConnection;
}

declare const Versions: {
    REST_VERSION: number;
    WEBSOCKET_VERSION: number;
};
declare const ShoukakuDefaults: Required<OptionalOptions>;
declare const ShoukakuClientInfo: string;
declare const NodeDefaults: NodeOption;

declare const Constants_NodeDefaults: typeof NodeDefaults;
declare const Constants_ShoukakuClientInfo: typeof ShoukakuClientInfo;
declare const Constants_ShoukakuDefaults: typeof ShoukakuDefaults;
declare const Constants_Versions: typeof Versions;
declare namespace Constants {
  export { Constants_NodeDefaults as NodeDefaults, Constants_ShoukakuClientInfo as ShoukakuClientInfo, Constants_ShoukakuDefaults as ShoukakuDefaults, Constants_Versions as Versions };
}

/**
 * Wrapper object around Lavalink
 */
declare class Player {
    /**
     * GuildId of this player
     */
    readonly guildId: string;
    /**
     * Lavalink node this player is connected to
     */
    connection: WeakRef<Connection>;
    constructor(connection: WeakRef<Connection>);
    get node(): Node;
    /**
     * Gets the current player info from lavalink
     */
    getData(): Promise<LavalinkPlayer>;
    /**
     * Destroys the player in remote Lavalink side
     */
    destroy(): Promise<void>;
    /**
     * Play a new track
     */
    playTrack(playerOptions: PlayOptions, noReplace?: boolean): Promise<void>;
    /**
     * Stop the currently playing track
     */
    stopTrack(): Promise<void>;
    /**
     * Pause or unpause the currently playing track
     * @param paused Boolean value to specify whether to pause or unpause the current bot user
     */
    setPaused(paused?: boolean): Promise<void>;
    /**
     * Seek to a specific time in the currently playing track
     * @param position Position to seek to in milliseconds
     */
    seekTo(position: number): Promise<void>;
    /**
     * Sets the global volume of the player
     * @param volume Target volume 0-1000
     */
    setGlobalVolume(volume: number): Promise<void>;
    /**
     * Sets the filter volume of the player
     * @param volume Target volume 0.0-5.0
     */
    setFilterVolume(volume: number): Promise<void>;
    /**
     * Change the equalizer settings applied to the currently playing track
     * @param equalizer An array of objects that conforms to the Bands type that define volumes at different frequencies
     */
    setEqualizer(equalizer: Band[]): Promise<void>;
    /**
     * Change the karaoke settings applied to the currently playing track
     * @param karaoke An object that conforms to the KaraokeSettings type that defines a range of frequencies to mute
     */
    setKaraoke(karaoke?: KaraokeSettings): Promise<void>;
    /**
     * Change the timescale settings applied to the currently playing track
     * @param timescale An object that conforms to the TimescaleSettings type that defines the time signature to play the audio at
     */
    setTimescale(timescale?: TimescaleSettings): Promise<void>;
    /**
     * Change the tremolo settings applied to the currently playing track
     * @param tremolo An object that conforms to the FreqSettings type that defines an oscillation in volume
     */
    setTremolo(tremolo?: FreqSettings): Promise<void>;
    /**
     * Change the vibrato settings applied to the currently playing track
     * @param vibrato An object that conforms to the FreqSettings type that defines an oscillation in pitch
     */
    setVibrato(vibrato?: FreqSettings): Promise<void>;
    /**
     * Change the rotation settings applied to the currently playing track
     * @param rotation An object that conforms to the RotationSettings type that defines the frequency of audio rotating round the listener
     */
    setRotation(rotation?: RotationSettings): Promise<void>;
    /**
     * Change the distortion settings applied to the currently playing track
     * @param distortion An object that conforms to DistortionSettings that defines distortions in the audio
     * @returns The current player instance
     */
    setDistortion(distortion?: DistortionSettings): Promise<void>;
    /**
     * Change the channel mix settings applied to the currently playing track
     * @param channelMix An object that conforms to ChannelMixSettings that defines how much the left and right channels affect each other (setting all factors to 0.5 causes both channels to get the same audio)
     */
    setChannelMix(channelMix?: ChannelMixSettings): Promise<void>;
    /**
     * Change the low pass settings applied to the currently playing track
     * @param lowPass An object that conforms to LowPassSettings that defines the amount of suppression on higher frequencies
     */
    setLowPass(lowPass?: LowPassSettings): Promise<void>;
    /**
     * Change the all filter settings applied to the currently playing track
     * @param filters An object that conforms to FilterOptions that defines all filters to apply/modify
     */
    setFilters(filters: FilterOptions): Promise<void>;
    /**
     * Clear all filters applied to the currently playing track
     */
    clearFilters(): Promise<void>;
    /**
     * If you want to update the whole player yourself, sends raw update player info to lavalink
     * @param playerOptions Options to update the player data
     * @param noReplace Set it to true if you don't want to replace the currently playing track
     */
    update(playerOptions: UpdatePlayerOptions, noReplace?: boolean): Promise<LavalinkPlayer>;
    /**
     * Sends server update to lavalink
     * @internal
     */
    sendServerUpdate(connection: Connection): Promise<void>;
}

export { type Address, AllowedPackets, type Band, type ChannelMixSettings, Connection, ConnectionState, Connector, type ConnectorOptions, Constants, type DistortionSettings, type EmptyResult, type ErrorResult, Events, type Exception, type FilterOptions, type FreqSettings, type KaraokeSettings, LavalinkOpCodes, type LavalinkPlayer, type LavalinkPlayerVoice, type LavalinkPlayerVoiceOptions, type LavalinkResponse, LoadType, type LowPassSettings, Node, type NodeCpu, type NodeFrameStats, type NodeInfo, type NodeInfoGit, type NodeInfoPlugin, type NodeInfoVersion, type NodeMemory, type NodeOption, type NonResumableHeaders, type OptionalOptions, type PlayOptions, Player, type PlayerEvent, PlayerEventType, type PlayerUpdate, type Playlist, type PlaylistResult, type Ready, type RequiredOptions, Rest, RestError, type ResumableHeaders, type RotationSettings, type RoutePlanner, type SearchResult, type ServerUpdate, type SessionInfo, type Severity, Shoukaku, type ShoukakuEvents, type StateUpdatePartial, type Stats, type Structures, type TimescaleSettings, type Track, type TrackEndEvent, type TrackEndReason, type TrackExceptionEvent, type TrackResult, type TrackStartEvent, type TrackStuckEvent, type UpdatePlayerInfo, type UpdatePlayerOptions, type UpdatePlayerTrackOptions, Utils, type VoiceChannelOptions, VoiceState, type WebSocketClosedEvent, createDiscordJSOptions, createErisOptions, createOceanicOptions, createSeyfertOptions };
