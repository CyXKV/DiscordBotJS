var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/Constants.ts
var Constants_exports = {};
__export(Constants_exports, {
  NodeDefaults: () => NodeDefaults,
  ShoukakuClientInfo: () => ShoukakuClientInfo,
  ShoukakuDefaults: () => ShoukakuDefaults,
  Versions: () => Versions
});

// package.json
var package_default = {
  name: "shoukaku",
  version: "5.0.0-dev",
  description: "A stable and updated wrapper around Lavalink",
  main: "dist/index.js",
  module: "dist/index.mjs",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: "./dist/index.mjs",
      require: "./dist/index.js"
    }
  },
  scripts: {
    build: "npm run build:ts && npm run build:docs",
    "build:ts": "tsup --config tsup-config.json",
    "build:docs": "typedoc --theme default --readme TypeDoc.md --name Shoukaku --out docs/ --entryPointStrategy expand src/.",
    lint: "eslint .",
    prepare: "npm run build:ts"
  },
  keywords: [
    "bot",
    "music",
    "lavalink",
    "api",
    "discord",
    "lavalink.js",
    "discord.js",
    "lavalink-api",
    "weeb-library"
  ],
  engines: {
    node: ">=18.0.0",
    npm: ">=7.0.0"
  },
  author: "Saya",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/shipgirlproject/Shoukaku.git"
  },
  dependencies: {
    ws: "^8.18.2"
  },
  devDependencies: {
    "@shipgirl/eslint-config": "^0.4.2",
    "@types/node": "^22.15.30",
    "@types/ws": "^8.18.1",
    eslint: "^9.28.0",
    "pkg-pr-new": "^0.0.51",
    tsup: "^8.5.0",
    typedoc: "^0.28.5",
    typescript: "^5.8.3"
  }
};

// src/model/Library.ts
var ConnectionState = /* @__PURE__ */ ((ConnectionState2) => {
  ConnectionState2[ConnectionState2["Connecting"] = 0] = "Connecting";
  ConnectionState2[ConnectionState2["Connected"] = 1] = "Connected";
  ConnectionState2[ConnectionState2["Disconnecting"] = 2] = "Disconnecting";
  ConnectionState2[ConnectionState2["Disconnected"] = 3] = "Disconnected";
  return ConnectionState2;
})(ConnectionState || {});
var VoiceState = /* @__PURE__ */ ((VoiceState2) => {
  VoiceState2[VoiceState2["SessionReady"] = 0] = "SessionReady";
  VoiceState2[VoiceState2["SessionIdMissing"] = 1] = "SessionIdMissing";
  VoiceState2[VoiceState2["AbortError"] = 2] = "AbortError";
  VoiceState2[VoiceState2["SessionEndpointMissing"] = 3] = "SessionEndpointMissing";
  VoiceState2[VoiceState2["SessionFailedUpdate"] = 4] = "SessionFailedUpdate";
  return VoiceState2;
})(VoiceState || {});
var Events = /* @__PURE__ */ ((Events2) => {
  Events2["Reconnecting"] = "reconnecting";
  Events2["Debug"] = "debug";
  Events2["Error"] = "error";
  Events2["Ready"] = "ready";
  Events2["Close"] = "close";
  Events2["Disconnect"] = "disconnect";
  Events2["PlayerUpdate"] = "playerUpdate";
  Events2["PlayerEvent"] = "playerEvent";
  return Events2;
})(Events || {});

// src/Constants.ts
var Versions = {
  REST_VERSION: 4,
  WEBSOCKET_VERSION: 4
};
var ShoukakuDefaults = {
  resume: false,
  resumeTimeout: 30,
  reconnectTries: 3,
  reconnectInterval: 5,
  restTimeout: 60,
  moveOnDisconnect: true,
  userAgent: "Discord Bot/unknown (https://github.com/shipgirlproject/Shoukaku.git)",
  structures: {},
  voiceConnectionTimeout: 15,
  nodeResolver: (nodes) => [...nodes.values()].filter((node) => node.state === 1 /* Connected */).sort((a, b) => a.penalties - b.penalties).shift()
};
var ShoukakuClientInfo = `${package_default.name}/${package_default.version} (${package_default.repository.url})`;
var NodeDefaults = {
  name: "Default",
  url: "",
  auth: "",
  secure: false,
  group: void 0
};

// src/Utils.ts
var Utils_exports = {};
__export(Utils_exports, {
  TypedEventEmitter: () => TypedEventEmitter,
  mergeDefault: () => mergeDefault,
  validate: () => validate,
  wait: () => wait
});
import { EventEmitter } from "events";

// src/model/Errors.ts
var ShoukakuError = class extends Error {
  constructor(context, message) {
    super(message);
    this.context = context;
  }
};
var MergeError = class extends Error {
  constructor(key, supplied) {
    super(`${key} was not found from the given options`);
    this.supplied = supplied;
  }
};
var UnexpectedError = class extends Error {
  constructor() {
    super("Unexepcted undefined value on a variable that is supposed not to");
  }
};
var ConnectionError = class extends Error {
  constructor(type) {
    let message;
    switch (type) {
      case 3 /* SessionEndpointMissing */: {
        message = "The voice connection is not established due to missing connection endpoint";
        break;
      }
      case 1 /* SessionIdMissing */: {
        message = "The voice connection is not established due to missing session id";
        break;
      }
      default:
        throw new UnexpectedError();
    }
    super(message);
    this.type = type;
  }
};
var ConnectionConnectTimeout = class extends Error {
  constructor(time) {
    super(`The voice connection is not established in ${time} second(s)`);
  }
};
var PlayerDerefError = class extends Error {
  constructor(guildId) {
    super(`The guild (${guildId}) connection can't be found, either you try to recreate the connection, or clean this up`);
  }
};

// src/Utils.ts
var TypedEventEmitter = class extends EventEmitter {
  constructor() {
    super();
  }
  on(eventName, listener) {
    return super.on(eventName, listener);
  }
  once(eventName, listener) {
    return super.once(eventName, listener);
  }
  off(eventName, listener) {
    return super.off(eventName, listener);
  }
  emit(eventName, ...args) {
    return super.emit(eventName, ...args);
  }
};
function mergeDefault(def, given) {
  if (!given) return def;
  const defaultKeys = Object.keys(def);
  for (const key in given) {
    if (defaultKeys.includes(key)) continue;
    delete given[key];
  }
  for (const key of defaultKeys) {
    if (def[key] === null || typeof def[key] === "string" && def[key].length === 0) {
      if (!given[key]) throw new MergeError(String(key), given);
    }
    if (given[key] === null || given[key] === void 0) given[key] = def[key];
  }
  return given;
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function validate(value) {
  if (typeof value === "undefined") {
    throw new UnexpectedError();
  }
  return value;
}

// src/connectors/Connector.ts
var AllowedPackets = ["VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE"];
var Connector = class {
  constructor(manager, options) {
    this.manager = manager;
    this.options = options;
    this.options.listenEvent(options.client, this.handleRaw.bind(this));
  }
  handleRaw(packet) {
    if (!AllowedPackets.includes(packet.t)) return;
    const guildId = packet.d.guild_id;
    const connection = this.manager.connections.find((conn) => conn.guildId === guildId);
    if (!connection) return;
    if (packet.t === "VOICE_SERVER_UPDATE") return connection.setServerUpdate(packet.d);
    const userId = packet.d.user_id;
    if (userId !== this.manager.userId) return;
    connection.setStateUpdate(packet.d);
  }
  sendPacket(shardId, payload) {
    return this.options.sendPacket(this.options.client, shardId, payload);
  }
};
function createDiscordJSOptions(client) {
  return {
    client,
    sendPacket: (client2, shardId, payload) => {
      return client2.ws.shards.get(shardId)?.send(payload, false);
    },
    listenEvent: (client2, handler) => {
      return void client2.on("raw", handler);
    }
  };
}
function createErisOptions(client) {
  return {
    client,
    sendPacket: (client2, shardId, payload) => {
      return client2.shards.get(shardId)?.sendWS(payload.op, payload.d, false);
    },
    listenEvent: (client2, handler) => {
      return void client2.on("rawWS", handler);
    }
  };
}
function createOceanicOptions(client) {
  return {
    client,
    sendPacket: (client2, shardId, payload) => {
      return client2.shards.get(shardId)?.send(payload.op, payload.d, false);
    },
    listenEvent: (client2, handler) => {
      return void client2.on("packet", handler);
    }
  };
}
function createSeyfertOptions(client) {
  return {
    client,
    sendPacket: (client2, shardId, payload) => {
      return client2.gateway.send(shardId, payload);
    },
    listenEvent: (client2, handler) => {
      client2.events.values.RAW = {
        data: { name: "raw" },
        run: handler
      };
    }
  };
}

// src/guild/Connection.ts
import { EventEmitter as EventEmitter2, once } from "events";
var Connection = class extends EventEmitter2 {
  /**
   * @param manager The manager of this connection
   * @param options The options to pass in connection creation
   * @param options.guildId GuildId in which voice channel to connect to is located
   * @param options.shardId ShardId in which the guild exists
   * @param options.channelId ChannelId of voice channel to connect to
   * @param options.deaf Optional boolean value to specify whether to deafen the current bot user
   * @param options.mute Optional boolean value to specify whether to mute the current bot user
   */
  constructor(manager, options) {
    super();
    this.manager = manager;
    this.guildId = options.guildId;
    this.channelId = options.channelId;
    this.shardId = options.shardId;
    this.muted = options.mute ?? false;
    this.deafened = options.deaf ?? false;
    this.sessionId = null;
    this.region = null;
    this.serverUpdate = null;
    this.state = 3 /* Disconnected */;
  }
  getNode() {
    return this.manager.nodes.find((node) => node.connections.has(this));
  }
  /**
   * Set the deafen status for the current bot user
   * @param deaf Boolean value to indicate whether to deafen or un-deafen
   * @defaultValue false
   */
  setDeaf(deaf = false) {
    this.deafened = deaf;
    this.sendVoiceUpdate();
  }
  /**
   * Set the mute status for the current bot user
   * @param mute Boolean value to indicate whether to mute or unmute
   * @defaultValue false
   */
  setMute(mute = false) {
    this.muted = mute;
    this.sendVoiceUpdate();
  }
  /**
   * Disconnect the current bot user from the connected voice channel
   * @internal
   */
  disconnect() {
    if (this.state === 3 /* Disconnected */) return;
    this.channelId = null;
    this.deafened = false;
    this.muted = false;
    this.removeAllListeners();
    this.sendVoiceUpdate();
    this.state = 3 /* Disconnected */;
    this.debug(`[Voice] -> [Node] & [Discord] : Connection Destroyed | Guild: ${this.guildId}`);
  }
  /**
   * Connect the current bot user to a voice channel
   * @internal
   */
  async connect() {
    if (this.state !== 3 /* Disconnected */) return;
    this.state = 0 /* Connecting */;
    this.sendVoiceUpdate();
    this.debug(`[Voice] -> [Discord] : Requesting Connection | Guild: ${this.guildId}`);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), this.manager.options.voiceConnectionTimeout * 1e3);
    try {
      const [status] = await once(this, "connectionUpdate", { signal: controller.signal });
      if (status !== 0 /* SessionReady */)
        throw new ConnectionError(status);
      this.state = 1 /* Connected */;
    } catch (e) {
      this.state = 3 /* Disconnected */;
      const error = e;
      this.debug(`[Voice] </- [Discord] : Request Connection Failed | Guild: ${this.guildId}`);
      if (error.name === "AbortError")
        throw new ConnectionConnectTimeout(this.manager.options.voiceConnectionTimeout);
      throw error;
    } finally {
      clearTimeout(timeout);
    }
  }
  /**
   * Updates SessionId, ChannelId, Deafen and Mute data of this instance
   * @param options
   * @param options.session_id Id of the current session
   * @param options.channel_id Id of the connected voice channel
   * @param options.self_deaf Boolean that indicates if the current bot user is deafened or not
   * @param options.self_mute Boolean that indicates if the current bot user is muted or not
   * @internal
   */
  setStateUpdate({ session_id, channel_id, self_deaf, self_mute }) {
    if (channel_id && channel_id !== this.channelId) {
      this.debug(`[Voice] <- [Discord] : Channel Moved | Old Channel: ${this.channelId} Guild: ${this.guildId}`);
    }
    this.channelId = channel_id ?? null;
    if (!this.channelId) {
      this.state = 3 /* Disconnected */;
      this.debug(`[Voice] <- [Discord] : Channel Disconnected | Guild: ${this.guildId}`);
      this.manager.leaveVoiceChannel(this.guildId);
    }
    this.deafened = self_deaf;
    this.muted = self_mute;
    this.sessionId = session_id ?? null;
    this.debug(`[Voice] <- [Discord] : State Update Received | Channel: ${this.channelId} Session ID: ${session_id} Guild: ${this.guildId}`);
  }
  /**
   * Sets the server update data for this connection
   * @internal
   */
  setServerUpdate(data) {
    if (!data.endpoint) {
      this.debug(`[Voice] <- [Discord] : Received a voice server update without an endpoint! Data => ${JSON.stringify(data)}`);
      return void this.emit("connectionUpdate", 3 /* SessionEndpointMissing */);
    }
    if (!this.sessionId) {
      this.debug(`[Voice] <- [Discord] : Received a voice server update without an session id! Data => ${JSON.stringify(data)}`);
      return void this.emit("connectionUpdate", 1 /* SessionIdMissing */);
    }
    const region = data.endpoint.split(".").shift()?.replace(/[0-9]/g, "");
    if (region !== this.region) {
      this.debug(`[Voice] <- [Discord] : Voice Region Moved | Old Region: ${this.region} New Region: ${region} Guild: ${this.guildId}`);
    }
    this.region = region ?? null;
    this.serverUpdate = data;
    this.debug(`[Voice] <- [Discord] : Server Update Received | Server: ${this.region} Guild: ${this.guildId}`);
    if (this.state !== 1 /* Connected */) {
      return void this.emit("connectionUpdate", 0 /* SessionReady */);
    }
    const node = this.getNode();
    if (!node) return;
    node.rest.updatePlayer(this.guildId, {
      voice: {
        token: data.token,
        endpoint: data.endpoint,
        sessionId: this.sessionId
      }
    }).catch(() => null);
  }
  /**
   * Send voice data to discord
   * @internal
   */
  sendVoiceUpdate() {
    this.send({ guild_id: this.guildId, channel_id: this.channelId, self_deaf: this.deafened, self_mute: this.muted });
  }
  /**
   * Send data to Discord
   * @param data The data to send
   * @private
   * @internal
   */
  send(data) {
    this.manager.connector.sendPacket(this.shardId, { op: 4, d: data });
  }
  /**
   * Emits a debug log
   * @private
   * @internal
   */
  debug(message) {
    this.manager.emit("debug" /* Debug */, message);
  }
};

// src/guild/Player.ts
var Player = class {
  constructor(connection) {
    if (!connection.deref()) throw new PlayerDerefError("Unknown");
    this.guildId = connection.deref().guildId;
    this.connection = connection;
  }
  get node() {
    const node = this.connection.deref()?.getNode();
    if (!node) {
      throw new PlayerDerefError(this.guildId);
    }
    return node;
  }
  /**
   * Gets the current player info from lavalink
   */
  getData() {
    return this.node.rest.getPlayer(this.guildId);
  }
  /**
   * Destroys the player in remote Lavalink side
   */
  async destroy() {
    await this.node.rest.destroyPlayer(this.guildId);
  }
  /**
   * Play a new track
   */
  async playTrack(playerOptions, noReplace = false) {
    await this.update(playerOptions, noReplace);
  }
  /**
   * Stop the currently playing track
   */
  async stopTrack() {
    await this.update({ track: { encoded: null }, position: 0 });
  }
  /**
   * Pause or unpause the currently playing track
   * @param paused Boolean value to specify whether to pause or unpause the current bot user
   */
  async setPaused(paused = true) {
    await this.update({ paused });
  }
  /**
   * Seek to a specific time in the currently playing track
   * @param position Position to seek to in milliseconds
   */
  async seekTo(position) {
    await this.update({ position });
  }
  /**
   * Sets the global volume of the player
   * @param volume Target volume 0-1000
   */
  async setGlobalVolume(volume) {
    await this.update({ volume });
  }
  /**
   * Sets the filter volume of the player
   * @param volume Target volume 0.0-5.0
   */
  async setFilterVolume(volume) {
    return this.setFilters({ volume });
  }
  /**
   * Change the equalizer settings applied to the currently playing track
   * @param equalizer An array of objects that conforms to the Bands type that define volumes at different frequencies
   */
  async setEqualizer(equalizer) {
    return this.setFilters({ equalizer });
  }
  /**
   * Change the karaoke settings applied to the currently playing track
   * @param karaoke An object that conforms to the KaraokeSettings type that defines a range of frequencies to mute
   */
  setKaraoke(karaoke) {
    return this.setFilters({ karaoke: karaoke ?? null });
  }
  /**
   * Change the timescale settings applied to the currently playing track
   * @param timescale An object that conforms to the TimescaleSettings type that defines the time signature to play the audio at
   */
  setTimescale(timescale) {
    return this.setFilters({ timescale: timescale ?? null });
  }
  /**
   * Change the tremolo settings applied to the currently playing track
   * @param tremolo An object that conforms to the FreqSettings type that defines an oscillation in volume
   */
  setTremolo(tremolo) {
    return this.setFilters({ tremolo: tremolo ?? null });
  }
  /**
   * Change the vibrato settings applied to the currently playing track
   * @param vibrato An object that conforms to the FreqSettings type that defines an oscillation in pitch
   */
  setVibrato(vibrato) {
    return this.setFilters({ vibrato: vibrato ?? null });
  }
  /**
   * Change the rotation settings applied to the currently playing track
   * @param rotation An object that conforms to the RotationSettings type that defines the frequency of audio rotating round the listener
   */
  setRotation(rotation) {
    return this.setFilters({ rotation: rotation ?? null });
  }
  /**
   * Change the distortion settings applied to the currently playing track
   * @param distortion An object that conforms to DistortionSettings that defines distortions in the audio
   * @returns The current player instance
   */
  setDistortion(distortion) {
    return this.setFilters({ distortion: distortion ?? null });
  }
  /**
   * Change the channel mix settings applied to the currently playing track
   * @param channelMix An object that conforms to ChannelMixSettings that defines how much the left and right channels affect each other (setting all factors to 0.5 causes both channels to get the same audio)
   */
  setChannelMix(channelMix) {
    return this.setFilters({ channelMix: channelMix ?? null });
  }
  /**
   * Change the low pass settings applied to the currently playing track
   * @param lowPass An object that conforms to LowPassSettings that defines the amount of suppression on higher frequencies
   */
  setLowPass(lowPass) {
    return this.setFilters({ lowPass: lowPass ?? null });
  }
  /**
   * Change the all filter settings applied to the currently playing track
   * @param filters An object that conforms to FilterOptions that defines all filters to apply/modify
   */
  async setFilters(filters) {
    await this.update({ filters });
  }
  /**
   * Clear all filters applied to the currently playing track
   */
  async clearFilters() {
    await this.update({ filters: void 0 });
  }
  /**
   * If you want to update the whole player yourself, sends raw update player info to lavalink
   * @param playerOptions Options to update the player data
   * @param noReplace Set it to true if you don't want to replace the currently playing track
   */
  async update(playerOptions, noReplace = false) {
    return this.node.rest.updatePlayer(this.guildId, playerOptions, noReplace);
  }
  /**
   * Sends server update to lavalink
   * @internal
   */
  async sendServerUpdate(connection) {
    await this.node.rest.updatePlayer(this.guildId, {
      voice: {
        token: connection.serverUpdate.token,
        endpoint: connection.serverUpdate.endpoint,
        sessionId: connection.sessionId
      }
    }, false);
  }
};

// src/model/Node.ts
var LavalinkOpCodes = /* @__PURE__ */ ((LavalinkOpCodes2) => {
  LavalinkOpCodes2["Ready"] = "ready";
  LavalinkOpCodes2["PlayerUpdate"] = "playerUpdate";
  LavalinkOpCodes2["Stats"] = "stats";
  LavalinkOpCodes2["Event"] = "event";
  return LavalinkOpCodes2;
})(LavalinkOpCodes || {});

// src/model/Player.ts
var PlayerEventType = /* @__PURE__ */ ((PlayerEventType2) => {
  PlayerEventType2["TrackStartEvent"] = "TrackStartEvent";
  PlayerEventType2["TrackEndEvent"] = "TrackEndEvent";
  PlayerEventType2["TrackExceptionEvent"] = "TrackExceptionEvent";
  PlayerEventType2["TrackStuckEvent"] = "TrackStuckEvent";
  PlayerEventType2["WebsocketClosedEvent"] = "WebSocketClosedEvent";
  return PlayerEventType2;
})(PlayerEventType || {});

// src/model/Rest.ts
var LoadType = /* @__PURE__ */ ((LoadType2) => {
  LoadType2["Track"] = "track";
  LoadType2["Playlist"] = "playlist";
  LoadType2["Search"] = "search";
  LoadType2["Empty"] = "empty";
  LoadType2["Error"] = "error";
  return LoadType2;
})(LoadType || {});

// src/node/Node.ts
import Websocket from "ws";

// src/node/Rest.ts
var Rest = class {
  /**
   * @param node An instance of Node
   * @param options The options to initialize this rest class
   * @param options.name Name of this node
   * @param options.url URL of Lavalink
   * @param options.auth Credentials to access Lavalink
   * @param options.secure Weather to use secure protocols or not
   * @param options.group Group of this node
   */
  constructor(node, options) {
    this.node = node;
    this.url = `${options.secure ? "https" : "http"}://${options.url}/v${Versions.REST_VERSION}`;
    this.auth = options.auth;
  }
  get sessionId() {
    return this.node.sessionId;
  }
  /**
   * Resolve a track
   * @param identifier Track ID
   * @returns A promise that resolves to a Lavalink response
   */
  async resolve(identifier) {
    const options = {
      endpoint: "/loadtracks",
      options: { params: { identifier } }
    };
    return validate(await this.fetch(options));
  }
  /**
   * Decode a track
   * @param track Encoded track
   * @returns Promise that resolves to a track
   */
  async decode(track) {
    const options = {
      endpoint: "/decodetrack",
      options: { params: { track } }
    };
    return validate(await this.fetch(options));
  }
  /**
   * Gets all the player with the specified sessionId
   * @returns Promise that resolves to an array of Lavalink players
   */
  async getPlayers() {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players`,
      options: {}
    };
    return validate(await this.fetch(options));
  }
  /**
   * Gets the player with the specified guildId
   * @returns Promise that resolves to a Lavalink player
   */
  async getPlayer(guildId) {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players/${guildId}`,
      options: {}
    };
    return validate(await this.fetch(options));
  }
  /**
   * Updates a Lavalink player
   * @param guildId GuildId of the player you want to update
   * @param updatePlayerOptions Data to update on the player
   * @param noReplace If you want this action to do nothing when the player is active
   * @returns Promise that resolves to a Lavalink player
   */
  async updatePlayer(guildId, updatePlayerOptions, noReplace = false) {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players/${guildId}`,
      options: {
        method: "PATCH",
        params: { noReplace: noReplace?.toString() ?? "false" },
        headers: { "Content-Type": "application/json" },
        body: updatePlayerOptions
      }
    };
    return validate(await this.fetch(options));
  }
  /**
   * Deletes a Lavalink player
   * @param guildId guildId where this player is
   */
  async destroyPlayer(guildId) {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players/${guildId}`,
      options: { method: "DELETE" }
    };
    await this.fetch(options);
  }
  /**
   * Updates the session with a resume boolean and timeout
   * @param resuming Whether resuming is enabled for this session or not
   * @param timeout Timeout to wait for resuming
   * @returns Promise that resolves to a Lavalink player
   */
  async updateSession(resuming, timeout) {
    const options = {
      endpoint: `/sessions/${this.sessionId}`,
      options: {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: { resuming, timeout }
      }
    };
    return validate(await this.fetch(options));
  }
  /**
   * Gets the status of this node
   * @returns Promise that resolves to a node stats response
   */
  async stats() {
    const options = {
      endpoint: "/stats",
      options: {}
    };
    return validate(await this.fetch(options));
  }
  /**
   * Get routeplanner status from Lavalink
   * @returns Promise that resolves to a routeplanner response
   */
  async getRoutePlannerStatus() {
    const options = {
      endpoint: "/routeplanner/status",
      options: {}
    };
    return validate(await this.fetch(options));
  }
  /**
   * Release blacklisted IP address into pool of IPs
   * @param address IP address
   */
  async unmarkFailedAddress(address) {
    const options = {
      endpoint: "/routeplanner/free/address",
      options: {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: { address }
      }
    };
    await this.fetch(options);
  }
  /**
   * Get Lavalink info
   */
  async getLavalinkInfo() {
    const options = {
      endpoint: "/info",
      options: {
        headers: { "Content-Type": "application/json" }
      }
    };
    return validate(await this.fetch(options));
  }
  /**
   * Make a request to Lavalink
   * @param fetchOptions.endpoint Lavalink endpoint
   * @param fetchOptions.options Options passed to fetch
   * @throws `RestError` when encountering a Lavalink error response
   * @internal
   */
  async fetch(fetchOptions) {
    const { endpoint, options } = fetchOptions;
    let headers = {
      "Authorization": this.auth,
      "User-Agent": this.node.manager.options.userAgent
    };
    if (options.headers) headers = { ...headers, ...options.headers };
    const url = new URL(`${this.url}${endpoint}`);
    if (options.params) url.search = new URLSearchParams(options.params).toString();
    const abortController = new AbortController();
    const timeout = setTimeout(() => abortController.abort(), this.node.manager.options.restTimeout * 1e3);
    const method = options.method?.toUpperCase() ?? "GET";
    const finalFetchOptions = {
      method,
      headers,
      signal: abortController.signal
    };
    if (!["GET", "HEAD"].includes(method) && options.body)
      finalFetchOptions.body = JSON.stringify(options.body);
    const request = await fetch(url.toString(), finalFetchOptions).finally(() => clearTimeout(timeout));
    if (!request.ok) {
      const response = await request.json().catch(() => null);
      throw new RestError(response ?? {
        timestamp: Date.now(),
        status: request.status,
        error: "Unknown Error",
        message: "Unexpected error response from Lavalink server",
        path: endpoint
      });
    }
    if (!request.body) return void 0;
    return await request.json();
  }
};
var RestError = class extends Error {
  constructor({ timestamp, status, error, trace, message, path }) {
    super(`Rest request failed with response code: ${status}${message ? ` | message: ${message}` : ""}`);
    this.name = "RestError";
    this.timestamp = timestamp;
    this.status = status;
    this.error = error;
    this.trace = trace;
    this.message = message;
    this.path = path;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// src/node/Node.ts
var _ws;
var Node = class {
  /**
      * @param manager Shoukaku instance
      * @param options Options on creating this node
      * @param options.name Name of this node
      * @param options.url URL of Lavalink
      * @param options.auth Credentials to access Lavalnk
      * @param options.secure Whether to use secure protocols or not
      * @param options.group Group of this node
      */
  constructor(manager, options) {
    /**
     * Websocket instance
     * @private
     */
    __privateAdd(this, _ws);
    this.manager = manager;
    this.rest = new (this.manager.options.structures.rest ?? Rest)(this, options);
    this.name = options.name;
    this.group = options.group;
    this.auth = options.auth;
    this.url = `${options.secure ? "wss" : "ws"}://${options.url}/v${Versions.WEBSOCKET_VERSION}/websocket`;
    this.state = 3 /* Disconnected */;
    this.reconnects = 0;
    this.stats = null;
    this.info = null;
    this.sessionId = null;
    this.connections = /* @__PURE__ */ new WeakSet();
    __privateSet(this, _ws, null);
  }
  /**
      * Penalties for load balancing
      * @returns Penalty score
      * @readonly
      */
  get penalties() {
    let penalties = 0;
    if (!this.stats) return penalties;
    penalties += this.stats.players;
    penalties += Math.round(Math.pow(1.05, 100 * this.stats.cpu.systemLoad) * 10 - 10);
    if (this.stats.frameStats) {
      penalties += this.stats.frameStats.deficit;
      penalties += this.stats.frameStats.nulled * 2;
    }
    return penalties;
  }
  /**
   * Node connections, this exists because weaksets can't be iterated on
   * @returns An array of connections being referenced by this node
   * @readonly
   * @internal
   */
  get mappedConnections() {
    return this.manager.connections.filter((connection) => this.connections.has(connection));
  }
  /**
      * Connect to Lavalink
   * @internal
      */
  async connect() {
    if (this.state !== 3 /* Disconnected */) return;
    this.state = 0 /* Connecting */;
    const headers = {
      "Client-Name": ShoukakuClientInfo,
      "User-Agent": this.manager.options.userAgent,
      "Authorization": this.auth,
      "User-Id": this.manager.userId
    };
    if (this.sessionId) {
      headers["Session-Id"] = this.sessionId;
      this.manager.emit("debug" /* Debug */, `[Socket] -> [${this.name}] : Session-Id is present, attempting to resume`);
    }
    this.manager.emit("debug" /* Debug */, `[Socket] -> [${this.name}] : Connecting to ${this.url} ...`);
    const createConnection = () => {
      const url = new URL(this.url);
      const server = new Websocket(url.toString(), { headers });
      const cleanup = () => {
        server.onopen = null;
        server.onclose = null;
        server.onerror = null;
      };
      return new Promise((resolve, reject) => {
        server.onopen = () => {
          cleanup();
          resolve(server);
        };
        server.onclose = () => {
          cleanup();
          reject(new Error("Websocket closed before a connection was established"));
        };
        server.onerror = (error2) => {
          cleanup();
          reject(new Error(`Websocket failed to connect due to: ${error2.message}`));
        };
      });
    };
    let error;
    for (; this.reconnects < this.manager.options.reconnectTries; this.reconnects++) {
      try {
        __privateSet(this, _ws, await createConnection());
        break;
      } catch (err) {
        this.manager.emit("debug" /* Debug */, `[Socket] -> [${this.name}] : Reconnecting in ${this.manager.options.reconnectInterval} seconds. ${this.manager.options.reconnectTries - this.reconnects} tries left`);
        await wait(this.manager.options.reconnectInterval * 1e3);
        error = err;
      }
    }
    this.reconnects = 0;
    if (error) {
      this.state = 3 /* Disconnected */;
      await this.handleOnDisconnect();
      throw error;
    }
    __privateGet(this, _ws).once("close", (...args) => void this.close(...args).catch((error2) => this.error(error2)));
    __privateGet(this, _ws).on("message", (data) => void this.message(data).catch((error2) => this.error(error2)));
    __privateGet(this, _ws).on("error", (error2) => this.error(error2));
  }
  /**
      * Disconnect from Lavalink
      * @param code Status code
      * @param reason Reason for disconnect
   * @internal
      */
  destroy(code, reason) {
    void this.close(code, Buffer.from(reason ?? "Unknown Reason", "utf-8"), true);
  }
  /**
      * Handle message from Lavalink
      * @param message JSON message
   * @private
      * @internal
      */
  async message(message) {
    const json = JSON.parse(message);
    if (!json) return;
    switch (json.op) {
      case "stats" /* Stats */:
        this.manager.emit("debug" /* Debug */, `[Socket] <- [${this.name}] : Node Status Update | Server Load: ${this.penalties}`);
        this.stats = json;
        break;
      case "ready" /* Ready */: {
        this.state = 1 /* Connected */;
        if (!json.sessionId) {
          this.manager.emit("debug" /* Debug */, `[Socket] -> [${this.name}] : No session id found from ready op? disconnecting and reconnecting to avoid issues`);
          return this.close(1e3, Buffer.from("No session-id found upon firing ready event", "utf-8"), false);
        }
        this.sessionId = json.sessionId;
        this.manager.emit("debug" /* Debug */, `[Socket] -> [${this.name}] : Lavalink is ready to communicate !`);
        this.manager.emit("ready" /* Ready */, this, json.resumed);
        if (this.manager.options.resume) {
          await this.rest.updateSession(this.manager.options.resume, this.manager.options.resumeTimeout);
          this.manager.emit("debug" /* Debug */, `[Socket] -> [${this.name}] : Resuming configured for this Session Id: ${this.sessionId}`);
        }
        break;
      }
      case "event" /* Event */: {
        this.manager.emit("playerEvent" /* PlayerEvent */, this, json);
        break;
      }
      case "playerUpdate" /* PlayerUpdate */: {
        this.manager.emit("playerUpdate" /* PlayerUpdate */, this, json);
        break;
      }
      default:
        this.manager.emit("debug" /* Debug */, `[Player] -> [Node] : Unknown Message Op, Data => ${JSON.stringify(json)}`);
    }
  }
  /**
      * Handle closed event from lavalink
      * @param code Status close
      * @param reason Reason for connection close
   * @param destroy If we should not try to connect again
   * @private
   * @internal
      */
  async close(code, reason, destroy = false) {
    if (this.state === 3 /* Disconnected */) return;
    this.state = 2 /* Disconnecting */;
    this.manager.emit("debug" /* Debug */, `[Socket] <-/-> [${this.name}] : Connection Closed, Code: ${code || "Unknown Code"}`);
    this.manager.emit("close" /* Close */, this, code, String(reason));
    __privateGet(this, _ws)?.removeAllListeners();
    __privateGet(this, _ws)?.terminate();
    __privateSet(this, _ws, null);
    if (!this.manager.options.resume) {
      this.sessionId = null;
    }
    this.state = 3 /* Disconnected */;
    if (destroy) {
      await this.handleOnDisconnect();
      return void this.manager.emit("disconnect" /* Disconnect */, this);
    }
    await this.connect();
  }
  /**
   * @private
   * @internal
   */
  async handleOnDisconnect() {
    const connections = this.mappedConnections.map(async (connection) => {
      this.connections.delete(connection);
      if (!this.manager.options.moveOnDisconnect) return;
      const node = this.manager.getIdealNode(connection);
      if (!node || !connection.serverUpdate || !connection.sessionId) {
        return void connection.disconnect();
      }
      try {
        await node.rest.updatePlayer(connection.guildId, {
          voice: {
            sessionId: connection.sessionId,
            endpoint: connection.serverUpdate.endpoint,
            token: connection.serverUpdate.token
          }
        });
      } catch (_) {
        return void connection.disconnect();
      }
    });
    await Promise.allSettled(connections);
  }
  /**
      * To emit error events easily
      * @param error error message
   * @private
   * @internal
      */
  error(error) {
    this.manager.emit("error" /* Error */, this, error);
  }
};
_ws = new WeakMap();

// src/Shoukaku.ts
var Shoukaku = class extends TypedEventEmitter {
  /**
   * @param required Required options for shoukaku to function
   * @param required.userId The user id of the user this instance will connect to
   * @param required.nodes List of initial nodes that the library will try to connect to
   * @param required.connectorOptions Options of the connector to communicate with Discord Websocket
   * @param optional Optional options to pass to create this Shoukaku instance
   * @param optional.resume Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES)
   * @param optional.resumeTimeout Time to wait before lavalink starts to destroy the players of the disconnected client
   * @param optional.resumeByLibrary Whether to resume the players by doing it in the library side (Client Side) (Note: TRIES TO RESUME REGARDLESS OF WHAT HAPPENED ON A LAVALINK SERVER)
   * @param optional.reconnectTries Number of times to try and reconnect to Lavalink before giving up
   * @param optional.reconnectInterval Timeout before trying to reconnect
   * @param optional.restTimeout Time to wait for a response from the Lavalink REST API before giving up
   * @param optional.moveOnDisconnect Whether to move players to a different Lavalink node when a node disconnects
   * @param optional.userAgent User Agent to use when making requests to Lavalink
   * @param optional.structures Custom structures for shoukaku to use
   * @param optional.nodeResolver Used if you have custom lavalink node resolving
   */
  constructor(required, optional = {}) {
    super();
    this.connector = new Connector(this, required.connectorOptions);
    this.options = mergeDefault(ShoukakuDefaults, optional);
    this.nodes = [];
    this.connections = [];
    this.userId = required.userId;
    for (const option of required.nodes) {
      this.nodes.push(new Node(this, option));
    }
  }
  /**
   * @returns The amount of cached player count
   */
  getPlayerCount() {
    let players = 0;
    for (const node of this.nodes.values()) {
      players += node.stats?.players ?? 0;
    }
    return players;
  }
  /**
   * @returns The latest player count being handled
   */
  async fetchPlayerCount() {
    let players = 0;
    for (const node of this.nodes.values()) {
      const player = await node.rest.getPlayers();
      players += player.length;
    }
    return players;
  }
  /**
   * Gets an ideal node based on the nodeResolver you provided
   * @param connection Optional connection class for ideal node selection, if you use it
   * @returns An ideal node for you to do things with
   */
  getIdealNode(connection) {
    return this.options.nodeResolver(this.nodes, connection);
  }
  /**
   * Connects every node that shoukaku manages if it's disconnected
   */
  async connect() {
    await Promise.all(this.nodes.map((node) => node.connect()));
  }
  /**
   * Connects a specific node shoukaku manages if it's disconnected
   * @param name Node name to connect
   */
  async connectNodeNamed(name) {
    const node = this.nodes.find((n) => n.name === name);
    await node?.connect();
  }
  /**
   * Add a Lavalink node to the pool of available nodes then tries to connect it
   * @param options.name Name of this node
   * @param options.url URL of Lavalink
   * @param options.auth Credentials to access Lavalnk
   * @param options.secure Whether to use secure protocols or not
   * @param options.group Group of this node
   */
  async addNode(options) {
    const node = new Node(this, options);
    await node.connect();
    this.nodes.push(node);
  }
  /**
   * Remove a Lavalink node from the pool of available nodes
   * @param name Name of the node
   * @param reason Reason of removing the node
   */
  removeNode(name, reason = "Remove node executed") {
    const index = this.nodes.findIndex((n) => n.name === name);
    if (index === -1)
      throw new ShoukakuError({ name, available: this.nodes.map((node2) => node2.name) }, "The node you are disconnecting from don't exist");
    const node = this.nodes.splice(index, 1)[0];
    node?.destroy(1e3, reason);
  }
  /**
   * Joins a voice channel
   * @param options.guildId GuildId in which the ChannelId of the voice channel is located
   * @param options.shardId ShardId to track where this should send on sharded websockets, put 0 if you are unsharded
   * @param options.channelId ChannelId of the voice channel you want to connect to
   * @param options.deaf Optional boolean value to specify whether to deafen or undeafen the current bot user
   * @param options.mute Optional boolean value to specify whether to mute or unmute the current bot user
   * @returns A weak reference to the connection, where you can create a new basic player by passing it to the class
   */
  async joinVoiceChannel(options) {
    if (this.connections.some((conn) => conn.guildId === options.guildId))
      throw new ShoukakuError(options, "This guild you are connecting to already have an existing connection");
    const connection = new Connection(this, options);
    this.connections.push(connection);
    try {
      await connection.connect();
    } catch (error) {
      this.deleteConnection(options.guildId);
      throw error;
    }
    const cleanup = () => {
      connection.disconnect();
      this.deleteConnection(options.guildId);
    };
    const node = options.node ?? this.getIdealNode(connection);
    if (!node) {
      cleanup();
      throw new ShoukakuError(options, "There's no node available to connect to");
    }
    try {
      await node.rest.updatePlayer(options.guildId, {
        voice: {
          token: connection.serverUpdate.token,
          endpoint: connection.serverUpdate.endpoint,
          sessionId: connection.sessionId
        }
      });
    } catch (error) {
      cleanup();
      throw error;
    }
    node.connections.add(connection);
    return new WeakRef(connection);
  }
  /**
   * Leaves a voice channel
   * @param guildId The id of the guild you want to delete
   * @returns The destroyed / disconnected player or undefined if none
   */
  leaveVoiceChannel(guildId) {
    const connection = this.connections.find((conn) => conn.guildId === guildId);
    connection?.disconnect();
    this.deleteConnection(guildId);
  }
  /**
   * Leaves current voice channel and joins a new one
   * @param guildId GuildId in which the ChannelId of the voice channel is located
   * @param channelId Id of channel to move to
   * @throws {@link Error} When guild does not have an existing connection, or could not be moved
   * @returns The moved player
   */
  moveVoiceChannel(guildId, channelId) {
    const connection = this.connections.find((conn) => conn.guildId === guildId);
    if (!connection)
      throw new ShoukakuError({ guildId, channelId }, "This guild don't have an existing connection");
    if (connection.channelId === channelId) return;
    connection.setStateUpdate({
      session_id: connection.sessionId,
      channel_id: channelId,
      self_deaf: connection.deafened,
      self_mute: connection.muted
    });
    connection.sendVoiceUpdate();
  }
  /**
   * Deletes a connection from array
   * @param guildId
   * @internal
   * @private
   */
  deleteConnection(guildId) {
    const index = this.connections.findIndex((conn) => conn.guildId === guildId);
    if (index === -1) return;
    return this.connections.splice(index, 1)[0];
  }
};
export {
  AllowedPackets,
  Connection,
  ConnectionState,
  Connector,
  Constants_exports as Constants,
  Events,
  LavalinkOpCodes,
  LoadType,
  Node,
  Player,
  PlayerEventType,
  Rest,
  RestError,
  Shoukaku,
  Utils_exports as Utils,
  VoiceState,
  createDiscordJSOptions,
  createErisOptions,
  createOceanicOptions,
  createSeyfertOptions
};
//# sourceMappingURL=index.mjs.map